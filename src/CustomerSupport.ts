// export interface CustomerSupport {
//     childOrderId: number
//     userId: number

import { UserRole } from "./User";

//     text: string
//     img: string | null
// }

// export class CustomerSupportEntity implements CustomerSupport {
//     constructor(
//         public childOrderId: number,
//         public userId: number,
//         public text: string,
//         public img: string | null
//     ) { }
// }

// export interface NewCustomerSupport {
//     childOrderId: number

//     text: string
// }

// export class NewCustomerSupportEntity implements NewCustomerSupport {
//     constructor(
//         public childOrderId: number,
//         public text: string
//     ) { }
// }
export enum CustomerSupportType {
    // Partner
    Partner_UnableToSendOnTime = 1,
    Partner_NoStock = 2,
    // User
    User_NotOnTime = 3,
    User_Generic = 4
}
export enum CustomerSupportAnswer {
    // Answers for Partner_UnableToSendOnTime
    Partner_UnableToSendOnTime_Reprogram = 1,
    Partner_UnableToSendOnTime_Cancel = 2,
    // Answers for Partner_NoStock
    Partner_NoStock_SendAnyway = 3,
    Partner_NoStock_Cancel = 4,
}
export const CustomerSupportTypeList = Object.values(CustomerSupportType).filter(value => typeof value === 'number');
export function getCustomerSupportTypeString(customerSupportType: CustomerSupportType): string {
    switch (customerSupportType) {
        case CustomerSupportType.Partner_UnableToSendOnTime:
            return "No se puede enviar a tiempo"
        case CustomerSupportType.Partner_NoStock:
            return "No hay stock"
        case CustomerSupportType.User_NotOnTime:
            return "No se entregÃ³ a tiempo"
        case CustomerSupportType.User_Generic:
            return "Otro"
    }
}
export const isAnswerAllowedByRole = (role: UserRole, answer: CustomerSupportAnswer): boolean => {
    switch (answer) {
        // Answers that a customer can give to a PQR generated by a partner
        case CustomerSupportAnswer.Partner_UnableToSendOnTime_Reprogram:
        case CustomerSupportAnswer.Partner_UnableToSendOnTime_Cancel:
        case CustomerSupportAnswer.Partner_NoStock_SendAnyway:
        case CustomerSupportAnswer.Partner_NoStock_Cancel:
            return [UserRole.User, UserRole.Partner].includes(role)
    }
}
export const isAnswerAllowedByType = (type: CustomerSupportType, answer: CustomerSupportAnswer): boolean => {
    switch (type) {
        case CustomerSupportType.Partner_UnableToSendOnTime:
            return answer === CustomerSupportAnswer.Partner_UnableToSendOnTime_Reprogram || answer === CustomerSupportAnswer.Partner_UnableToSendOnTime_Cancel
        case CustomerSupportType.Partner_NoStock:
            return answer === CustomerSupportAnswer.Partner_NoStock_SendAnyway || answer === CustomerSupportAnswer.Partner_NoStock_Cancel
        case CustomerSupportType.User_NotOnTime:
        case CustomerSupportType.User_Generic:
            return true;
    }
}
export interface CustomerSupport {
    childOrderId: number
    userCreatorId: number
    userAnsweredId: number
    type: CustomerSupportType
    answer: CustomerSupportAnswer | null
    genericText: string | null
}
export class CustomerSupportEntity implements CustomerSupport {
    constructor(
        public childOrderId: number,
        public userCreatorId: number,
        public userAnsweredId: number,
        public type: CustomerSupportType,
        public answer: CustomerSupportAnswer | null,
        public genericText: string | null
    ) { }
}
export interface NewCustomerSupport {
    childOrderId: number
    type: CustomerSupportType
}